서블릿 컨테이너는 서블릿을 처리하기위한 프로그램이다.
톰캣은 HTTP의 request/response요청을  
각각 javax.servlet.ServletRequest와 javax.servlet.ServletResponse를 구현한 것으로 처리한다. 
서블릿의 로드는 URLClassLoader를 사용하여서 로드한다.
Request와 Response를 구현한것들은 접근 제한을 위해서 Facade패턴으로 클래스를 하나더 많든다. 

* 서블릿은 javax.servlet.Servlet 인터페이스를 구현한것으로 주요메서드는 service이다.
* 서블릿 컨테이너에서 클래스 로더가 서블릿 클래스를 찾는 위치를 저장소(repository)라고 부른다.
** 톰캣은 저장소의 위치를 @java.net.URL@을 통해서 지정한다.
* Request와 Response의 초기화가 노출되지 않게 하기위해서 Facade를 만들어서 사용한다. 

---

정적리소스외에 논리적인것(서블릿)을 처리하는 방법에 대한 기초를 설명한다.
> uri에 의해서 정적리소스와 서블릿을 분리해서 처리한다
> 기본적인 서블릿 처리방법 : 서블릿의 생명주기에 의한 처리  
>> javax.servlet.Servlet인터페이스에 의한 생명주기 
>> 요청을 받을때 서블릿은 '로더'에 의해서 'repository'라는 저장소에 저장되며, 
>> 각 서블릿은 저장소에 호출될때 서블릿의 init를 호출한후에 서블릿의 service메서드를 실행한다.
>> 서블릿이 처리된후에는 destroy를 호출한다.  

특이한것은 서블릿을 처리하는것과 정적리소스를 처리하는 클래스 모두 process를 쓴다는 것이다.
이것은 언젠가 interface로 통일 된다는 말인것일까?

이번장은 그냥 소켓통신을 서블릿 컨테이너를 통해서 작업하도록 하는것이다.
> 서블릿 컨테이너는 자바를 실행시키기위한 환경을 만드는 것이다.
> 이번장은 서블릿 컨테이너에서 통신부분만을 처리하도록 한다.
> 이전것과 커다란 변화는 정적인것만처리하던것을 동적인것을 처리하도록 만든것이다. 
>>동적인것 처리는 당연 자바에서 맏는다. 그게 서블릿이라는 일정 규격으로 포장되어있을뿐이다. 

* 컨테이너 
** 컨테이너라는 것은 클래스를 메모리에 가지고 있는것을 의미한다. 메모리에는 객체가 들어가겠지?
** 컨테이너에는 클래스들의 객체들이 모여있는 것이다. 
** 컨테이너는 각 객체의 생명주기를 책임지게 된다. 
* 저장소(repository)
** 클래스를 모아두는 곳을 다른말로 Repository라고 해야하나?
*** 서빌릿 컨테이너에서는 클래스 로더가 서블릿 클래스를 찾는 위치를 저장소(repository)라고 부른다.
* 클래스 로더
** 클래스를 메모리에 로드하는 것.자세한설명은 나중에...
* URL
** http,ftp,telnet 등의 서비스를 지원하는 웹 서버들의 위치를 표현하는 체계이다.
* URL 클래스 : url이라는 인터넷주소라는 문자(spec)를 해석하기 위한 클래스 
** 웹상의 주소(URL)을 나타내는 클래스이다.
** InetAddress클래스보다 확장된 개념으로 네트워크 연결까지 가능하다. 따라서 URL객체 생성 시 잘못된 URL형태를 주었을때의 예외처리를 반드시 해야한다.

역할분담
> HttpServer1 : 요청을 받아들인다.
> Request : 요청을 분석한다, servletRequest를 구현한다.
> Response : 요청을 처리한다,servletResponse를 구현한다.
>> uri가 servlet으로 시작하면, 해당 클래스에서 실행한다.
>> uri가 servlet으로 시작하지 않으면, 요청 파일을 읽어서 리턴한다.
> StaticResourceProcessor : 요청파일을 읽어서 리턴하도록 실행한다. 정적자원을 처리한다.
> ServletProcessor1 : 처리할 자바 클래스를 불러와서 처리한다. 요청 서블릿을 실행한다.
> Constants : 상수를 저장하기 위한 곳, 작업공간 

* 서블릿 인터페이스는 서블릿에 대한 생명주기를 맏는다.
** "클라이언트 요청을 처리하고 그 결과를 다시 클라이언트에게 전송하는 Servlet 인터페이스의 구현 규칙을 지킨 자바 프로그램"
** "Server + Let" or "Server + Applet"
** 참조 : http://breath91.tistory.com/entry/Servlet-%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80
* 디스패치(dispatch) : 디스패치하다는 말은 다중 프로그래밍 시스템에서 다음에 처리될 작업을 선택하여 실행시키는 것. 
** 즉, 대기 열에서 기다리고 있는 프로세스를 선택하여 중앙 처리 장치의 사용 권한을 부여하는 작업.
** 참조 : https://kldp.org/node/4266

url요청에 따라서 서블릿을 구분해서 Response를 처리하도록 클래스를 분리한다.
> 살짝 전략패턴?!
> 서블릿은 클래스를 로드해서 처리한다.

기타사항
> 작업디렉토리는 Constants에서 관리한다.
> Request와 Response는 서블릿인터페이스를 구현한다.
 


---
역할분담
> HttpServer는 요청을 기다렸다가 받는역할
> Request는 요청을 분석하는 역할 
> Response는 요청에 대한 대답, 현재는 파일을 던저준다.

실행 : http://localhost:8080/index.html
> 실행을 위해서 index.html을 넣고 index.html에서 호출하는 이미지도 받는다.

웹서버는 간단한 소켓통신으로부터 기원한다. 
> 클라이언트는 socket으로 만들고, 서버는 ServerSocket 클래스로 만든다.
> request는 uri를 분석하는데 쓰인다.
> response는 요청한 파일을 읽어서 내보낸다.
>> 파일 읽고 쓰기 필요 

클라이언트 요청
> 처음에 index.html을 요청하면 서버는 index.html를 보내준다.
> 클라이언트는 index.html을 분석한다. 
>> 거기에 이미지가 있으면 서버에 다시 재요청을 보내 이미지파일을 요청한다.

* URI : 작업디렉토리의 최상위를 나타내며, 항상 슬래시(/)로 시작한다.
** http://localhost:8080/index.html이면 /index.html을 나타낸다.
** (대신 was의 컨텍스트가 web일때) http://localhost:8080/web/index.html에서는 /web/index.html이 아닌 /index.html이 되겠다. 
** URL은 사실상 URI의 한 종류이다.(http://www.ietf.org/rfc/rfc2396.txt)
*** http메서드를 분석할때 나오는 것이 URI이다. 
** 통상적인말 : 인터넷자원을 지정한다. 대부분의 경우, URI는 서버의 최상위 디렉토리의 상대 경로로 나타낸다.(와~ 무슨말인지 느낌이 안온다.)