컨테이너는 서블릿 요청을 처리하고 웹 클라이언트에게 보낼 응답 객체를 만들어 주는 컴포넌트이다.

톰캣은 org.apache.catalina.Container를 구현한 컨테이너를 사용한다.

컨테이너 인스턴스는 커넥터의 setContainer메소드에 전달돼 커넥터가 컨테이너의 invoke메소드를 호출하게 한다.
* invoke를 호출하는 곳이 있다는데 대체 어디있는지 안보인다.

컨테이너는 아래의 4단계가 존재한다.
# 엔진(Engine) : 카탈리나 서블릿 엔진전체
# 호스트(Host) : 각 컨텍스트에 따른 가상 호스트를 붙여준다. 가상호스트는 외부에서 접속하는 곳이 될곳이다.
# 컨텍스트(Context) : 웹애플리케이션, 둘이상의 래퍼를 가진다.
## 컨텍스트는 다수의 서블릿 구현을 위해서 Mapper를 가지고 있다.(톰캣5이후에는 다른방식)
# 래퍼(Wrapper) : 각각의 서블릿, 서블릿에 보기좋게 몇가지 더 추가되게 한다.
## 중요한것은 allocate와 load
* 컨테이너는 하위 컨테이너를 넣을수 있다.

컨테이너는 Loader,Logger,Manager(세션관리),Realm(인증), Resources와 같은 다양한 지원 컴포넌트를 가질수 있다.
> 컨테이너 인터페이스는 톰캣 관리자가 설정파일(server.xml)을 편집함으로써 컨테이너의 동작방식을 배치시에 결정할 수 있게 설계됐다는 점이 흥미롭다.
> 이것은 파이프라인과 밸브를 도입하면서 가능하다.
* 각 컴포넌트는 Lifecycle인터페이스를 구현해야한다.
* Lifecycle를 구현한 컴포넌트는 다양한 이벤트를 하나이상 발생시킬수 있는데, 그러면 이벤트가 발생할때 수행될 로직을 호출 할수 있는 이벤트 리스너도 존재해야한다.
* 이벤트 리스너는 org.apache.catalina.LifecycleListener인터페이스로 나타낸다.

Lifecycle의 주요메서드는 start(),stop()이다.
* 굿이 리스너에 등록하는것은 절약과 속도를 위해서...전체적으로 쓰는거면 리스너로 등록해도 될지 모르겠다.

컨테이너는 로더를 통해서 WEB-INF/classes와 WEB-INF/lib에 있는것을 저장소에 올릴수 있다.
* 로더중에 reloader이 있는데, 이것때문에 서버재시작없이 배포해서 되는 것 같다.
* 캐싱 : 이거... 강력하면 골치아픈 그것같다. 수정했는데도 캐시된것 사용하고 반영안되는 것...

모든 컨테이너는 Pipleline와 Valve로 로직을 처리하게 된다.
하나의 컨테이너는 하나의 파이프라인을 가질수 있고 컨테이너의 invoke가 호출되면 파이프라인으로 처리권을 넘기며, 파이프라인은 밸브를 호출하여서 밸브에 처리를 넘긴다.
invokenext()는 다음에 어떤 밸브를 호출해야하닌지 기억하기 위해서 변수를 사용한다.
* 파이프라인과 Valve는 체인필터와 체인의 관계와 같다.
* 컨테이너가 하는일은 컨테이너에 직접 코딩되어있지 않고 파이프라인의 invoke메서드를 호출한다.