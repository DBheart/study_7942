커넥터중에서 톰캣에서 사용하는 커넥터의 기본적인것을 살펴본다.
Http요청이 어떻게 여러개를 처리할수 있는지를 알아본다
Http요청이 어떻게 Stateless가 될수 있는지 알아본다.

원리
> 부트스트랩 : 어떤 커넥터를 쓰고, 어떤 컨테어니를 쓰는지 결정한다.
> 커넥터 : 여러개의 프로세서를 호출할수 있게 한다. 스택에 쌓아놓는다. 물론 갯수 제한은 있다.
>> 각 프로세서는 각각의 쓰레드에서 활동한다.
>> 시작은 HttpConnector은 두개가 실행되지 않고, HttpProcess는 여러개 생성할수 있다.
>> 여기서 HttpProcess는 클라이언트에 대한 요청이라고 생각하면 될것 같다.
>> createProcessor메서드로 인해서 새로운 HttpProcess를 생성하지 않고, 객체풀(Stack)에 있는 HttpProcess를 사용할 것이다. 
> HttpProcess 작동원리 : 이부분이 상당히 이해하기 어렵다. 그냥 비동기적으로 실행된다는것만 알아두어도...
>> assign메서드로 인해서 비동기적으로 작동하게 되어서, HttpProcess에 대한객체를 바로 반납할수 있게한다.
>>> 쓰레드이기때문에 가능한것같다. 일단 쓰레드는 멈춰있고, HttpProcess는 돌려준다. 그다음에 호출되는 쓰레드가 다시 실행(notifyAll()을 호출)을 시킨다.
>>> 마치 비지터(?) 패턴같다.
>>> 이걸알면 비동기가 어떻게 처리되는지 알수 있을지도 모른다.
>>> 비동기는 그러면 쓰레드를 이용한 비지터패턴인건가? notifyAll로 모두 깨우고 다니는?!

팩터리패턴은 대부분 객체풀을 위한것일지도....

* 3장에서의 HttpConnector 인스턴스는 한번에 하나의 HttpProcessor인스턴스를 갖기 때문에, 한번에 Http 요청하나만을 처리할 수있었다.
기본 커넥터에서 HttpConnector는 HttpProcessor객체의 풀을 가지며, 각 HttProcessor 인스턴스는 자신의 스레드를 가진다. 
따라서 HttpConnector는 동시에 여러 HTTP 요청을 처리 할수 있게 된다.
HttpConnector는 HttpProcessor객체가 매번 생성되는 것을 방지하기 위해 HttpProcessor의 풀을 관리한다.
HttpProcessor의 인스턴스는 java.io.Stack타입의 processors라는 멤버변수에 저장된다. 

Runable로 해놓으면 그냥 생성만해도 실행이 되는것인가?
> Runable로 해놓고 Thread를 생성해서 Thread.start()를 하면 해당 클래스의 run() 부분이 실행된다.

다음에는 아파치의 소스를 한번살펴보도록 하자.
그다음에는 스프링소스를 분석?! 해보자. 될려나?
사간프로젝트도 알아봐야하는데.... 그건

<변경사항>
1. HttpConnection은 인스턴스 자신이 쓰레드로 실행하기 위해서 Runable를 구현하는것 뿐만아니라 생명주기 관리를 위해서 Lifecycle를 구현한다.
2. HttpConnection은 커넥션풀을 관리하여서 다수의 HttpProcessor인스턴스를 받는다.
	- ServerSocket의 생성자를 받는 대신에  서버소켓의 팩터리로부터 ServerSocket인스턴스를 얻는다.
	- 이렇게 됨으로써 다수의 HTTP 요청처리가 될수 있는 것이다.
3. HttpConnection은 하나의 컨테이너와 관계를 가지게 된다.(여기는 커넥션만 보므로 설명은 여기까지)	
4. 톰캣라이브러리를 사용한 커넥터, 간단한 컨테이너 생성, 실행을위한 부트스트랩은 그대로 간다.
	- 여기서는 정적리소스를 호출할수 없다.서블릿만 호출이 가능하다.

-------

톰캣라이브러리를 거의사용했다.


* 커넥션 스레드와 프로세서 스레드
** 프로세서 스레드 : 
** 커넥션 스레드 : 
* 팩터리 패턴은... 커넥션풀상태를 만들때 좋은것일까? 